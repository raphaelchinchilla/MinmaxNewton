function [status,iter,times_sol] = ip_newton_minmax(obj,t,params_optim)
% This function implements the interior point/newton method for minmax
% problem described in the paper. The algorithm is guarateed to only
% converge towards local minmax points.

% Input parameters:
% obj: tenscalc object generated by generate_tens_function
% t: [optional] initial value of barrier parameter
% params_optim: [optional] struct with non-default values for optimization
% parameters. Struct names need to match values bellow. Only needs to input
% values that change the default.
% Output
% iter: number of iterations
% times_sol: time to solve optimization
% status: describes whether optimization succeeded, and if not, why it
% failed. The output status is a number in base 10 that needs to be
% converted to a number in base 4 using base2dec(status,4).
% If status>0 solver terminated unexpectedly, and each digit different than
% 0 represents a reason why it failed.

% *  0  = success
% 	*  >0 = solver terminated unexpectedly
% 	a nonzero status indicates the reason for termination
% 	in a base 4 format:
% 	digit  0 = 1 - (primal) variables violate constraints
% 	digit  1 = 1 - dual variables are negative
% 	digit  2 = 1 - failed to invert hessian
% 	digit  2 = 2 - failed to compute epsilons
% 	digit  3 = 1 - maximum # of iterations reached
% 	when the solver exists because the maximum # of iterations
% 	was reached (digit 3 = 1), the remaining digits provide
% 	information about the solution returned. If the digit = 1, the
% 	minimizer failed, if the digit = 2 the maximizer failed if the digit =3
% 	both failed.
% 	digit  4 = 1/2/3 - gradient larger then gradTolerance
% 	digit  5 = 1/2/3 - equality constraints violate equalTolerance
% 	digit  6 = 1/2/3 - duality gap larger than desiredDualityGap
% 	digit  7 = 1/2/3 - barrier variable larger than minimum value
% 	digit  8 = 1/2/3 - scalar gain alpha in Newton direction
% 		    smaller than alphaMin
% 	digit  9 = 1/2/3 - scalar gain alpha in Newton direction
% 		    smaller than .1
% 	digit 10 = 1/2/3 - scalar gain alpha in Newton direction
% 		    smaller than .5

    %% Initializing optimization parameters
    delta_L=1e-5; % tolerance for gradient of lagrangian
    delta_G=1e-5; % tolerance for equality constraints
    delta_F=1e-5; % tolerance for inequality constraints
    delta_gap=1e-5; % gap between optimality conditions and barrier
    gamma_agressive=0.33; % change value of barrier if good step
    gamma_conservative=0.75; % change value of barrier if bad step
    max_iter=100; % maximum number of iterations
    tau=0.99; % fraction to the boundary rule
    alpha_max=1; % maximum step size for alpha, lower it for ill scaled problems
    delta_l= 1; % determines when to switch between each type of adjustement of epsilons
    adjust_eps=true; % whether to adjust the epsilons 
    decouple_alpha=false; % whether the stepsizes should be decoupled for primal and dual variables
    eta_x=0; %minimum value of epsilon_x
    eta_y=0; %minimum value of epsilon_y
    %Defining gammas, used to stabilize the LDL decomposition. Multiplied by identity and added to Hessian. p for primal, d for dual
    gamma_px=sqrt(eps);
    gamma_dx=sqrt(eps);
    gamma_py=sqrt(eps);
    gamma_dy=sqrt(eps);
    
    if nargin==1
        t=1;
    end
    
    if nargin==3
        fs=fields(params_optim);
        for i=1:length(fs)
            if ~exist(fs{i},'var')
                error(['Optimization parameter "',fs{i}, '" is no valid. Check ip_newton_minmax parameter list']) 
            end
        end
       struct2workspace(params_optim) 
    end

    inertia = @(D) [length(find(D>0)),length(find(D<0)),length(find(D==0))];

    tic()
    %% Initializing function variables
    initPrimal__(obj)    
    [n_x,l_x,m_x,n_y,l_y,m_y]=get_sizes(obj);    
    % defining initial barrier parameters    
    setA_t_(obj,t)
    if l_x+m_x+l_y+m_y>0 %checking if there are constraints before initializing
        initDual__(obj);
    end    
    
  
    % Setting initial values for inverting the Hessian
    corr.mu=0;
    corr.eps_x=0;
    corr.eps_y=0;
    corr.eta_x=eta_x;
    corr.eta_y=eta_y;
    setA_eps_x_(obj,corr.eps_x)
    setA_eps_y_(obj,corr.eps_y)
    setA_gamma_px_(obj,gamma_px)
    setA_gamma_dx_(obj,gamma_dx)    
    setA_gamma_py_(obj,gamma_py)
    setA_gamma_dy_(obj,gamma_dy)
    
    
    
    %% Solving the optimization
    iter=0;
    no_error=true;
    norm_g=get_norm_g(obj);
    if isnan(norm_g) || isinf(norm_g)
        no_error=false;
    end
    
    
    [norm_gx,norm_gy,norm_gnu_x,norm_gnu_y,norm_glambda_x,norm_glambda_y,norm_gs_x,norm_gs_y]=get_norms(obj);
    while iter<max_iter && no_error && (norm_gx>delta_L || norm_gy>delta_L || norm_gnu_x>delta_G || norm_gnu_y>delta_G || norm_glambda_x>delta_F || norm_glambda_y>delta_F || norm_gs_x>delta_gap || norm_gs_y>delta_gap )
%     while iter<max_iter && no_error && get_norm_g(obj)>delta_L


        
        if adjust_eps && no_error 
            if norm_g>delta_l
                [corr,no_error]=adjusteps_far(obj,corr,n_x,m_x,l_x,n_y,m_y,l_y);
            else
                [corr,no_error]=adjusteps_close(obj,corr,n_x,m_x,l_x,n_y,m_y,l_y);
            end
        end

        setA_tau(obj,tau);
        % Calculating maximum step for each of the components
        [alpha_s_x,alpha_s_y,alpha_lambda_x,alpha_lambda_y]=get_alphas(obj);
        
        alpha_s_x=min(alpha_s_x,1);
        alpha_s_y=min(alpha_s_y,1);
        alpha_lambda_x=min(alpha_lambda_x,1);
        alpha_lambda_y=min(alpha_lambda_y,1);


        alpha=min([alpha_s_x,alpha_s_y,alpha_lambda_x,alpha_lambda_y]);
        
        if ~decouple_alpha
            alpha_s_x=alpha;
            alpha_s_y=alpha;
            alpha_lambda_x=alpha;
            alpha_lambda_y=alpha;
        end
        setA_alpha_p_x_(obj,alpha_s_x)
        setA_alpha_p_y_(obj,alpha_s_y)
        setA_alpha_d_x_(obj,alpha_lambda_x)
        setA_alpha_d_y_(obj,alpha_lambda_y)
        
        
        % Applying step sizes
        applyStepsUpdateVariables__(obj)
                       
        % Calculating new barrier parameter        
        [norm_gx,norm_gy,norm_gnu_x,norm_gnu_y,norm_glambda_x,norm_glambda_y,norm_gs_x,norm_gs_y]=get_norms(obj);       
        if alpha>alpha_max/2 && norm_gx<100*delta_L && norm_gy<100*delta_L && norm_gnu_x<100*delta_G && norm_gnu_y<100*delta_G && norm_glambda_x<100*delta_F && norm_glambda_y<100*delta_F
%         if alpha>alpha_max/2 && get_norm_g(obj)<100*delta_L
            t=t*gamma_agressive;            
        else
            t=t*gamma_conservative;
        end
        setA_t_(obj,t)
        
        norm_g=get_norm_g(obj);
        if isnan(norm_g) || isinf(norm_g)
            no_error=false;
        end        
       
        iter=iter+1;
    end
    
    
    
    if not(no_error)
        norm_g=get_norm_g(obj);
        if (isnan(norm_g) || isinf(norm_g))
            status="100";
        else
            status="200";
        end
        status=base2dec(status,4);
    elseif iter<max_iter
        status=0; 
        setA_eps_y_(obj,0)
        setA_eps_x_(obj,0)
%         setA_gamma_px_(obj,0)    
%         setA_gamma_py_(obj,0)
        if ~isequal(inertia(get_ldlHyy(obj)),[l_y+m_y,n_y+m_y,0]) || ~isequal(inertia(get_ldlH(obj)),[n_x+m_x+l_y+m_y,l_x+m_x+n_y+m_y,0])
            status=0.5;
        end
    else
        [norm_gx,norm_gy,norm_gnu_x,norm_gnu_y,norm_glambda_x,norm_glambda_y,norm_gs_x,norm_gs_y]=get_norms(obj);       
        status="1000";
        track=0;
        if norm_gx>delta_L
            track=track+1;
        end
        if norm_gy>delta_L
            track=track+2;
        end
        status=string(track)+status;
        
        track=0;
        if norm_gnu_x>delta_G 
            track=track+1;
        end        
        if norm_gnu_y>delta_G 
            track=track+2;
        end
        status=string(track)+status;
        
        track=0;
        if norm_glambda_x>delta_F || norm_gs_x>delta_gap 
            track=track+1;
        end
        if norm_glambda_y>delta_F || norm_gs_y>delta_gap 
            track=track+2;
        end
        status=string(track)+status;
        
       status=base2dec(status,4);
    end
    
    times_sol=toc();

end


function [corr,no_error]=adjusteps_far(obj,corr,n_x,m_x,l_x,n_y,m_y,l_y)

inertia = @(D) [length(find(D>0)),length(find(D<0)),length(find(D==0))];

no_error=true;
max_eps=1e4;

% Initializing with no correction
setA_eps_y_(obj,0)
setA_eps_x_(obj,0)

% Adjusting epsilons for y
D=get_ldlHyy(obj);
if isequal(inertia(D),[l_y+m_y,n_y+m_y,0])
    corr.eps_y=corr.eta_y;
else
    corr.eps_y=max([corr.eps_y/2,corr.eta_y,sqrt(eps)]);
    setA_eps_y_(obj,corr.eps_y)
    
    D=get_ldlHyy(obj);
    while ~isequal(inertia(D),[l_y+m_y,n_y+m_y,0]) &&  corr.eps_y<max_eps
        corr.eps_y=corr.eps_y*10;
        setA_eps_y_(obj,corr.eps_y)
        D=get_ldlHyy(obj);
    end

end


% Adjusting epsilons for x
D=get_ldlH(obj);
if isequal(inertia(D),[n_x+m_x+l_y+m_y,l_x+m_x+n_y+m_y,0])
    corr.eps_x=corr.eta_x;
else
    corr.eps_x=max([corr.eps_x/2,corr.eta_x,sqrt(eps)]);    
    setA_eps_x_(obj,corr.eps_x)
    
    D=get_ldlH(obj);
    while ~isequal(inertia(D),[n_x+m_x+l_y+m_y,l_x+m_x+n_y+m_y,0]) && corr.eps_x<max_eps
        corr.eps_x=corr.eps_x*10;
        setA_eps_x_(obj,corr.eps_x)
        D=get_ldlH(obj);
    end
end

if corr.eps_y>=max_eps || corr.eps_x>=max_eps
    no_error=false;
end

end

function [corr,no_error]=adjusteps_close(obj,corr,n_x,m_x,l_x,n_y,m_y,l_y)

inertia = @(D) [length(find(D>0)),length(find(D<0)),length(find(D==0))];
no_error=true;
max_eps=1e4;
max_length_mu=200;
mu=[];

% Initializing with no correction
setA_eps_y_(obj,0)
setA_eps_x_(obj,0)


% Adjusting epsilons for y
D=get_ldlHyy(obj);
inertia_Hyy=inertia(D);
if isequal(inertia_Hyy,[l_y+m_y,n_y+m_y,0])
    corr.eps_y=corr.eta_y;

    D=get_ldlH(obj);
    if isequal(inertia(D),[n_x+m_x+l_y+m_y,l_x+m_x+n_y+m_y,0])
        setA_eps_y_(obj,corr.eps_y)
        corr.eps_x=corr.eta_x;
        setA_eps_x_(obj,corr.eps_x)
        
        if corr.eps_y~=0        
            D=get_ldlHaux(obj);       
            while ~isequal(inertia(D),[n_x+m_x+n_y+l_y+2*m_y,l_x+m_x,0]) && corr.eps_x<max_eps
                corr.eps_x=corr.eps_x*10;
                setA_eps_x_(obj,corr.eps_x)      
                D=get_ldlHaux(obj);
            end
        end
               
    else
        setA_eps_y_(obj,corr.eps_y)       
        corr.eps_x=max([corr.eps_x/2,corr.eta_x,sqrt(eps)]);
        setA_eps_x_(obj,corr.eps_x)

        D=get_ldlH(obj);
        while ~isequal(inertia(D),[n_x+m_x+l_y+m_y,l_x+m_x+n_y+m_y,0]) && corr.eps_x<max_eps
            corr.eps_x=corr.eps_x*10;
            setA_eps_x_(obj,corr.eps_x)
            D=get_ldlH(obj);
        end
    end
    
else
    inertia_H=inertia(get_ldlH(obj));
    % Testing with \bar mu=0
    if inertia_Hyy(3)==0 && (n_x+m_x<inertia_Hyy(2)-l_y-m_y || (inertia_H(3)==0 && inertia_H(1)>=n_x+m_x+l_y+m_y+1) )
        shortcut=true;
    else
        shortcut=false;
    end    

    % Start by computing epsilon_x and epsilon_y that satisfy the ConsLQAC

    % Computing epsilon_y
    corr.eps_y=max([corr.eps_y/2,corr.eta_y,sqrt(eps)]);
    setA_eps_y_(obj,corr.eps_y)

    D=get_ldlHyy(obj);
    while ~isequal(inertia(D),[l_y+m_y,n_y+m_y,0]) && corr.eps_y<max_eps
        corr.eps_y=corr.eps_y*10;
        setA_eps_y_(obj,corr.eps_y)
        D=get_ldlHyy(obj);
    end
    

    % Adjusting epsilon_x
    corr.eps_x=max([corr.eps_x/2,corr.eta_x,sqrt(eps)]);
    setA_eps_x_(obj,corr.eps_x)

    D=get_ldlH(obj);
    while ~isequal(inertia(D),[n_x+m_x+l_y+m_y,l_x+m_x+n_y+m_y,0]) && corr.eps_x<max_eps
        corr.eps_x=corr.eps_x*10;
        setA_eps_x_(obj,corr.eps_x)
        D=get_ldlH(obj);
    end
    
    
    if not(shortcut) && corr.eps_x<max_eps % cases where we cannot use the bar mu=0 to guarantee the existance of mu
        i_y_pos=inertia_Hyy(1);
        i_y_zero=inertia_Hyy(3);
        found_it=false;
        
        % Testing if the last version of mu works for some values of eps_x
        setA_eps_y_(obj,corr.mu*corr.eps_y)
        inertia_Hyy=inertia(get_ldlHyy(obj));
        
        setA_eps_x_(obj,corr.mu*corr.eps_x)               
        inertia_H=inertia(get_ldlH(obj));         
        if inertia_Hyy(2)<n_y+m_y && inertia_H(1)>=n_x+m_x+l_y+m_y+1
            found_it=true;
        elseif inertia_Hyy(2)==n_y+m_y && inertia_H(1)<n_x+m_x+l_y+m_y
            found_it=true;
        else
            % testing value of epsilon_x twice as large.
            setA_eps_x_(obj,corr.mu*2*corr.eps_x)               
            inertia_H=inertia(get_ldlH(obj));       
            if inertia_Hyy(2)<n_y+m_y && inertia_H(1)>=n_x+m_x+l_y+m_y+1
                found_it=true;
                corr.eps_x=2*corr.eps_x;
            elseif inertia_Hyy(2)==n_y+m_y && inertia_H(1)<n_x+m_x+l_y+m_y
                found_it=true;
                corr.eps_x=2*corr.eps_x;
            end            
        end
        
       
        
        % If it did not work, find new set of mu to test
        if not(found_it)
            mu=sort(rand(2*(i_y_pos+i_y_zero-l_y-m_y),1));
            setA_eps_y_(obj,mu(ceil(length(mu)/2))*corr.eps_y)
            inertia_Hyy=inertia(get_ldlHyy(obj));        

            while inertia_Hyy(2)==n_y+m_y && length(mu)<max_length_mu       
                mu=[sort(mu(1)*rand(ceil(0.2*length(mu)),1));mu];
                setA_eps_y_(obj,mu(ceil(length(mu)/2))*corr.eps_y)
                inertia_Hyy=inertia(get_ldlHyy(obj));  
            end

            % Bisection algorithm to find where is the mu_1 such that for all
            % mu>mu_1  (among the mu we sampled) inertia_Hyy(2)==n_y+m_y
            setA_eps_y_(obj,mu(end)*corr.eps_y)
            inertia_Hyy=inertia(get_ldlHyy(obj));
            if inertia_Hyy(2)<n_y+m_y
                mu_star=length(mu);
            else
                mu_low=floor(length(mu)/2); %we know from above that for mu_low, inertia_Hyy(2)<n_y+m_y
                mu_up=length(mu);
                mu_star=mu_low;
                if mu_up-mu_low<=1
                    mu_star=mu_low;
                else                
                    while mu_up-mu_low>1
                        mu_star=round((mu_low+mu_up)/2);
                        setA_eps_y_(obj,mu(mu_star)*corr.eps_y)
                        inertia_Hyy=inertia(get_ldlHyy(obj));
                        if inertia_Hyy(2)<n_y+m_y
                            mu_low=mu_star;
                        else
                            mu_up=mu_star;
                        end
                    end           
                    if inertia_Hyy(2)==n_y+m_y
                        mu_star=mu_star-1;
                    end
                end
            end
            
            
            % Increasing mu and testing until discovering whether one of
            % them works
            while not(found_it) && corr.eps_x<max_eps
                mu_k=1;
                while not(found_it) && mu_k<length(mu)
                    setA_eps_x_(obj,mu(mu_k)*corr.eps_x)
                    setA_eps_y_(obj,mu(mu_k)*corr.eps_y)               
                    inertia_H=inertia(get_ldlH(obj));                
                    if mu_k<=mu_star && inertia_H(1)>=n_x+m_x+l_y+m_y+1
                        found_it=true;
                        corr.mu=mu(mu_star);
                    elseif mu_k>mu_star && inertia_H(1)<n_x+m_x+l_y+m_y
                        found_it=true;
                        corr.mu=mu(mu_star);
                    end
                    mu_k=mu_k+1;
                end
                if not(found_it)
                    corr.eps_x=corr.eps_x*5;
                end
            end
        end
    end
    setA_eps_x_(obj,corr.eps_x)
    setA_eps_y_(obj,corr.eps_y)
end


if corr.eps_y>=max_eps || corr.eps_x>=max_eps || length(mu)>=max_length_mu
    no_error=false;
end

end

